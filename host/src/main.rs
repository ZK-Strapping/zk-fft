// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{HELLO_GUEST_ELF, HELLO_GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use zk_fft_core::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();

    // input : [a0, a1, ..., an] for a0 + a1 * x + ... + an * x^n
    let input = CircuitInput {
        n: 2,
        ax: vec![-1.0, 1.0], // -1 + x
        m: 5,
        bx: vec![1.0, 1.0, 1.0, 1.0, 1.0], // 1 + x + x^2 + x^3 + x^4
    };

    // generate proof
    let receipt = generate_proof(input)?;
    print_journal(&receipt);

    // verify
    receipt.verify(HELLO_GUEST_ID).unwrap();

    Ok(())
}

pub fn generate_proof(input: CircuitInput) -> Result<Receipt, Box<dyn std::error::Error>> {
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();
    let prover = default_prover();
    let receipt = prover.prove(env, HELLO_GUEST_ELF).unwrap();
    Ok(receipt)
}

fn print_journal(receipt: &Receipt) {
    let journal: CircuitJournal = receipt.journal.decode().unwrap();
    let input = journal.input;
    let output = journal.output;
    println!(
        "Public Input: n = {}, ax = {:#?},\nm = {}, bx = {:#?}",
        input.n, input.ax, input.m, input.bx
    );
    println!("Public output: {:#?}", output);
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::Rng;
    use std::fs::File;
    use std::io::{prelude::*, BufReader};
    use std::time::Instant;

    // #[test]
    fn test_poly_mul_test_case() -> Result<(), Box<dyn std::error::Error>> {
        let test_case = "example_00";
        let input_file =
            File::open(format!("./src/tests/in/{}.in", test_case)).expect("file not found");
        let mut input_lines = BufReader::new(input_file).lines();

        let nm: Vec<_> = input_lines
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse::<usize>().unwrap())
            .collect();
        let n: usize = nm[0];
        let m: usize = nm[1];

        let ax: Vec<f32> = input_lines
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse::<f32>().unwrap())
            .collect();
        let bx: Vec<f32> = input_lines
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse::<f32>().unwrap())
            .collect();

        let output_file =
            File::open(format!("./src/tests/out/{}.out", test_case)).expect("file not found");
        let real_output: Vec<f32> = BufReader::new(output_file)
            .lines()
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse().unwrap())
            .collect();

        let input = CircuitInput { n, ax, m, bx };
        let receipt = generate_proof(input)?;
        print_journal(&receipt);

        let journal: CircuitJournal = receipt.journal.decode().unwrap();
        let output = journal.output;
        assert_eq!(&output[..(n + m - 1)], real_output);

        Ok(())
    }

    #[test]
    fn test_poly_mul_1() {
        test_poly_mul_n(1);
    }

    #[test]
    fn test_poly_mul_10() {
        test_poly_mul_n(10);
    }

    #[test]
    fn test_poly_mul_50() {
        test_poly_mul_n(50);
    }

    #[test]
    fn test_poly_mul_100() {
        test_poly_mul_n(100);
    }

    #[test]
    fn test_poly_mul_1000() {
        test_poly_mul_n(1000);
    }

    #[test]
    fn test_poly_mul_4096() {
        test_poly_mul_n(4096);
    }

    fn test_poly_mul_n(n: usize) {
        let mut rng = rand::thread_rng();
        let ax: Vec<f32> = (0..n).map(|_| rng.gen_range(-100..=100) as f32).collect();
        let bx: Vec<f32> = (0..n).map(|_| rng.gen_range(-100..=100) as f32).collect();

        let input = CircuitInput { n, ax, m: n, bx };
        let timer = Instant::now();
        let receipt = generate_proof(input).unwrap();
        let proving_time = timer.elapsed();
        print_journal(&receipt);
        println!("[n = {n}] Proving time: {:?}", proving_time);

        let journal: CircuitJournal = receipt.journal.decode().unwrap();
        check_poly_mul(journal.input, journal.output);

        let timer = Instant::now();
        receipt.verify(HELLO_GUEST_ID).unwrap();
        let verifying_time = timer.elapsed();
        println!("[n = {n}] Verifying time: {:?}", verifying_time);
    }

    fn check_poly_mul(input: CircuitInput, output: CircuitOutput) {
        // polynomial multiplication in O(n^2)
        let mut real_output = vec![0.; input.n + input.m - 1];
        for i in 0..input.n {
            for j in 0..input.m {
                real_output[i + j] += input.ax[i] * input.bx[j];
            }
        }

        // Exact comparison
        // assert_eq!(&output[..(input.n + input.m - 1)], real_output);

        // Approximate comparison
        let diff = real_output
            .iter()
            .zip(output.iter())
            .map(|(x, y)| (x - y).abs())
            .max_by(|x, y| x.partial_cmp(y).unwrap())
            .unwrap();
        let eps = 1e-6;
        assert!(diff < eps);
    }
}
