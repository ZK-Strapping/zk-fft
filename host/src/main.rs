// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{HELLO_GUEST_ELF, HELLO_GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use zk_fft_core::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();

    // input : [a0, a1, ..., an] for a0 + a1 * x + ... + an * x^n
    let input = CircuitInput {
        n: 2,
        ax: vec![-1.0, 1.0], // -1 + x
        m: 5,
        bx: vec![1.0, 1.0, 1.0, 1.0, 1.0], // 1 + x + x^2 + x^3 + x^4
    };

    let receipt = generate_proof(input)?;

    receipt.verify(HELLO_GUEST_ID).unwrap();

    Ok(())
}

fn generate_proof(input: CircuitInput) -> Result<Receipt, Box<dyn std::error::Error>> {
    let env = ExecutorEnv::builder().write(&input)?.build().unwrap();
    let prover = default_prover();
    let receipt = prover.prove_elf(env, HELLO_GUEST_ELF).unwrap();
    let journal: CircuitJournal = receipt.journal.decode().unwrap();

    let input = journal.input;
    let output = journal.output;
    println!(
        "Input: n = {}, ax = {:#?},\n m = {}, bx = {:#?}",
        input.n, input.ax, input.m, input.bx
    );
    println!("Public output: {:#?}", output);

    Ok(receipt)
}

fn check_poly_mul(input: CircuitInput, output: CircuitOutput) {
    let mut rng = rand::thread_rng();

    for k in rand::seq::index::sample(&mut rng, input.n + input.m - 1, 100).into_iter() {
        let mut c = 0.0;
        for i in 0..=k {
            c += input.ax[i] * input.bx[k - i];
        }
        assert_eq!(c, output[k]);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::io::{prelude::*, BufReader};

    #[test]
    fn test_poly_mul() -> Result<(), Box<dyn std::error::Error>> {
        env_logger::init();

        let test_case = "example_00";
        let input_file =
            File::open(format!("./src/tests/in/{}.in", test_case)).expect("file not found");
        let mut input_lines = BufReader::new(input_file).lines();

        let nm: Vec<_> = input_lines
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse::<usize>().unwrap())
            .collect();
        let n: usize = nm[0];
        let m: usize = nm[1];

        let ax: Vec<f64> = input_lines
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse::<f64>().unwrap())
            .collect();
        let bx: Vec<f64> = input_lines
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse::<f64>().unwrap())
            .collect();

        let output_file =
            File::open(format!("./src/tests/out/{}.out", test_case)).expect("file not found");
        let real_output: Vec<f64> = BufReader::new(output_file)
            .lines()
            .next()
            .unwrap()?
            .split_whitespace()
            .map(|x| x.parse().unwrap())
            .collect();

        let input = CircuitInput { n, ax, m, bx };
        let receipt = generate_proof(input)?;
        let journal: CircuitJournal = receipt.journal.decode().unwrap();
        let output = journal.output;
        assert_eq!(&output[..(n + m - 1)], real_output);

        Ok(())
    }
}
